(require "/usr/lib/fuzuli/nfl/math.nfl")

(class Matrix extends Object
	(block
		(def data LIST)
		(def n INTEGER)
		(def m INTEGER)


		(function create (params rows cols)
			(block
				(let n rows)
				(let m cols)
				(let data (: 1 rows))
				(for (let i 0) (< i rows) (++ i)
					(set data i (: 1 cols))
				)
				(fill data 0.0)
			)
		)
		
		(function getData (params)
			(return data)
		)


		(function clear (params)
			(fill 0.0)
		)

		(function get (params row col)
			(return (nth (nth data row) col))
		)

		(function setValue (params row col value)
			(set (nth data row) col value)
		)

		(function transpose (params)
			(block
				(let tr (new Matrix))
				(tr.create m n)
				(for (let i 0) (< i n) (++ i)
					(for (let j 0) (< j m) (++ j)
						(tr.setValue j i (get i j))
					)
				)
				(return tr)
			)
		)


		(function clonematrix (params)
			(block
				(let mat (new Matrix))
				(mat.create n m)
				(for (let i 0) (< i n) (++ i)
          (for (let j 0) (< j m) (++ j)
            (mat.setValue i j (get i j))
          )
        )
				(return mat)
			)
		)

		(function echelon (params)
			(block
				(def temp LIST)
				(let i 0)(let j 0)(let k 0)
				(let temp (clonematrix))
				(def pivot FLOAT)
				(for (let i 0)(< i n)(++i)
					(for (let j (+ i 1))(< j m)(++j)
						(let pivot (/ (* -1 (temp.get j i)) (temp.get i i)))
						(for (let k 0)(< k cols)(++k)
							(temp.setValue j k (+ (* (temp.get i k) pivot) (temp.get j k)))
						)
					)
				)
				(return temp)
			)
		)

		(function det (params)
			(block
				(let ech (echelon))
				(let determinant 1.0)
				(for (let i 0) (< i n) (++ i)
					(let determinant (* determinant (ech.get i i)))
				)
				(return determinant)
			)
		)

		(function minor (params x y)
			(block
			  (let cnt 0)
				(let temp (clonematrix))
				(let newmat (new Matrix))
				(newmat.create (- n 1) (- m 1))
				(let myarr (: 0 (* (- n 1) (- m 1))))
				(for (let i 0) (< i n) (++ i)
					(for (let j 0) (< j m) (++ j)
						(if (and (!= i x) (!= j y))
							(block
								(set myarr cnt (temp.get i j))
								(++ cnt)
							)
						)
					)
				)
				(let cnt 0)
				(for (let i 0)(< i (- n 1))(++ i)
					(for (let j 0)(< j (- m 1))(++ j)
						(newmat.setValue i j (nth myarr cnt))
						(++ cnt)
					)
				)
				(return newmat)
			)
		)

		(function inverse (params)
			(block
				(let determinant (det))
				(if (or (!= n m) (= det 0))
					(block
						(print "Cannot invert matrix\n")
						(return)
					)
				)
				(let temp (clonematrix))
				(let cofactor (new Matrix))
				(cofactor.create n m)
				(for (let j 0)(< j m)(++j)
					(for (let i 0)(< i n)(++i)
						(let mintemp (temp.minor i j))
						(let tempdet (mintemp.det))
						(cofactor.setValue i j tempdet)
					)
				)
				(let cofactor (cofactor.transpose))
				(for (let i 0)(< i n)(++ i)
					(for (let j 0)(< j m)(++ j)
						(let val (/ (* (cofactor.get i j) (pow -1.0 (+ i j))) det))
						(cofactor.setValue i j val)
					)
				)		
				(return cofactor)
			)	
		)

	)
)
(println "Creating matrix")
(let a (new Matrix))
(println "Called new")
(a.create 2 2)
(a.setValue 0 0 1)(a.setValue 0 1 2)(a.setValue 1 0 3)(a.setValue 1 1 4)
(print "Original: " (a.getData) "\n")
(let trans (a.transpose))
(print "Transpose: " (trans.getData) "\n")
(let klon (a.clonematrix))
(print "Klon: " (klon.getData) "\n")
(let echelon (a.echelon))
(print "Echelon: " (echelon.getData) "\n")
(let det (a.det))
(print "Determinant: " det "\n")
(let minor (a.minor 0 0))
(print "Minor: " (minor.getData) "\n")
(let inverse (a.inverse))
(print "Inverse: " (inverse.getData) "\n")
